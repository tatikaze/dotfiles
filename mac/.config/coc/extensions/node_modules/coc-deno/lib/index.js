var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __assign = Object.assign;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// client/src/extension.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
var import_coc3 = __toModule(require("coc.nvim"));

// client/src/commands.ts
var import_coc2 = __toModule(require("coc.nvim"));

// client/src/constants.ts
var EXTENSION_NS = "deno";
var EXTENSION_TS_PLUGIN = "typescript-deno-plugin";
var TS_LANGUAGE_FEATURES_EXTENSION = "coc-tsserver";
var PRETTIER_EXTENSION = "coc-prettier";

// client/src/lsp_extensions.ts
var import_coc = __toModule(require("coc.nvim"));
var cache = new import_coc.RequestType("deno/cache");
var virtualTextDocument = new import_coc.RequestType("deno/virtualTextDocument");

// client/src/commands.ts
function cache2(_context, client2) {
  return async () => {
    const {document} = await import_coc2.workspace.getCurrentState();
    return import_coc2.window.withProgress({
      title: "caching",
      cancellable: true
    }, () => {
      return client2.sendRequest(cache, {
        referrer: {uri: document.uri.toString()},
        uris: [],
        textDocument: {uri: document.uri.toString()}
      });
    });
  };
}
function initializeWorkspace() {
  return async () => {
    const title = "Initialize Deno Project";
    const linting = "Enable Deno linting?";
    const unstable = "Enable Deno unstable APIs?";
    const prettier = "Disable coc-prettier for current project?";
    const items = [linting, unstable];
    if (import_coc2.extensions.all.find((e) => e.id === PRETTIER_EXTENSION)) {
      items.push(prettier);
    }
    const settings = await import_coc2.window.showPickerDialog(items, title);
    if (!settings)
      return;
    await import_coc2.workspace.nvim.command(`CocRestart`, true);
    const config = import_coc2.workspace.getConfiguration(EXTENSION_NS);
    config.update("enable", true);
    config.update("lint", settings.includes(linting));
    config.update("unstable", settings.includes(unstable));
    if (settings.includes(prettier)) {
      const prettierConfig = import_coc2.workspace.getConfiguration("prettier");
      prettierConfig.update("disableLanguages", ["typescript", "javascript"]);
    }
    import_coc2.window.showMessage("Deno is now setup in this workspace.");
  };
}
function showReferences() {
  return (uri, position, locations) => {
    if (!uri)
      return;
    import_coc2.commands.executeCommand("editor.action.showReferences", import_coc2.Uri.parse(uri), position, locations);
  };
}
function status(_context, _client) {
  return async () => {
    const content = await _client.sendRequest(virtualTextDocument, {
      textDocument: {uri: "deno:/status.md"}
    });
    import_coc2.window.echoLines(content.split("\n"));
  };
}

// client/src/content_provider.ts
var DenoTextDocumentContentProvider = class {
  constructor(client2) {
    this.client = client2;
  }
  provideTextDocumentContent(uri, token) {
    return this.client.sendRequest(virtualTextDocument, {textDocument: {uri: uri.toString()}}, token);
  }
};

// client/src/extension.ts
function assert(cond, msg = "Assertion failed.") {
  if (!cond) {
    throw new Error(msg);
  }
}
var settingsKeys = [
  "codeLens",
  "config",
  "enable",
  "importMap",
  "lint",
  "unstable"
];
function synchronizeConfiguration(api) {
  api == null ? void 0 : api.configurePlugin(EXTENSION_TS_PLUGIN, getSettings());
}
function getSettings() {
  var _a, _b;
  const settings = import_coc3.workspace.getConfiguration(EXTENSION_NS);
  const result = Object.create(null);
  for (const key of settingsKeys) {
    const value = settings.inspect(key);
    assert(value);
    result[key] = (_b = (_a = value.workspaceValue) != null ? _a : value.globalValue) != null ? _b : value.defaultValue;
  }
  return result;
}
var client;
async function activate(context) {
  var _a, _b, _c;
  const registerCommand = createRegisterCommand(context);
  const enable = import_coc3.workspace.getConfiguration(EXTENSION_NS).get("enable", false);
  if (!enable) {
    registerCommand("initializeWorkspace", initializeWorkspace);
    return;
  }
  const tsserver = import_coc3.extensions.all.find((e) => e.id === TS_LANGUAGE_FEATURES_EXTENSION);
  if (tsserver) {
    await tsserver.activate();
    synchronizeConfiguration(tsserver.exports);
  }
  const command = import_coc3.workspace.getConfiguration(EXTENSION_NS).get("path", "deno");
  const run = {
    command,
    args: ["lsp"],
    options: {env: __assign(__assign({}, process.env), {NO_COLOR: true})}
  };
  const docSet = new Set();
  const clientOptions = {
    documentSelector: [
      {scheme: "file", language: "javascript"},
      {scheme: "file", language: "javascriptreact"},
      {scheme: "file", language: "typescript"},
      {scheme: "file", language: "typescriptreact"},
      {scheme: "deno", language: "javascript"},
      {scheme: "deno", language: "javascriptreact"},
      {scheme: "deno", language: "typescript"},
      {scheme: "deno", language: "typescriptreact"}
    ],
    diagnosticCollectionName: "deno",
    initializationOptions: getSettings(),
    middleware: {
      provideDefinition: async (document, position, token, next) => {
        if (docSet.has(document.uri))
          return;
        docSet.add(document.uri);
        const def = await next(document, position, token);
        docSet.delete(document.uri);
        return def;
      }
    }
  };
  client = new import_coc3.LanguageClient("deno-language-server", "Deno Language Server", run, clientOptions);
  const statusBarItem = import_coc3.window.createStatusBarItem(0);
  context.subscriptions.push(statusBarItem);
  context.subscriptions.push(import_coc3.workspace.onDidChangeConfiguration((evt) => {
    if (evt.affectsConfiguration(EXTENSION_NS)) {
      client.sendNotification("workspace/didChangeConfiguration", {settings: null});
      if (tsserver) {
        synchronizeConfiguration(tsserver.exports);
      }
    }
  }), import_coc3.workspace.registerTextDocumentContentProvider(EXTENSION_NS, new DenoTextDocumentContentProvider(client)));
  registerCommand("cache", cache2);
  registerCommand("status", status);
  registerCommand("initializeWorkspace", initializeWorkspace);
  import_coc3.commands.registerCommand(`${EXTENSION_NS}.showReferences`, showReferences, null, true);
  context.subscriptions.push(client.start());
  await client.onReady();
  const serverVersion = ((_c = (_b = (_a = client.initializeResult) == null ? void 0 : _a.serverInfo) == null ? void 0 : _b.version) != null ? _c : "").split(" ")[0];
  if (serverVersion) {
    statusBarItem.text = `Deno ${serverVersion}`;
    statusBarItem.show();
  }
}
function deactivate() {
  return client == null ? void 0 : client.stop();
}
function createRegisterCommand(context) {
  return function registerCommand(name, factory) {
    const fullName = `${EXTENSION_NS}.${name}`;
    const command = factory(context, client);
    context.subscriptions.push(import_coc3.commands.registerCommand(fullName, command));
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
